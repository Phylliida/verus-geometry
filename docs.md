# API Reference

*Auto-generated by verus-docgenerator*

## `orient2d`

### Spec Functions

- **`open spec fn det2d`** — [orient2d.rs:15](./src/orient2d.rs#L15)
  > 2D determinant: det2d(u, v) = u.x*v.y - u.y*v.x
- **`open spec fn orient2d`** — [orient2d.rs:20](./src/orient2d.rs#L20)
  > 2D orientation predicate: orient2d(a, b, c) = det2d(b-a, c-a)

### Proof Functions

- **`proof fn lemma_orient2d_swap_bc`** — [orient2d.rs:377](./src/orient2d.rs#L377)
  > orient2d(a, c, b) ≡ -orient2d(a, b, c)
- **`proof fn lemma_orient2d_degenerate_ab`** — [orient2d.rs:389](./src/orient2d.rs#L389)
  > orient2d(a, a, c) ≡ 0
- **`proof fn lemma_orient2d_degenerate_bc`** — [orient2d.rs:423](./src/orient2d.rs#L423)
  > orient2d(a, b, b) ≡ 0
- **`proof fn lemma_orient2d_cyclic`** — [orient2d.rs:432](./src/orient2d.rs#L432)
  > orient2d(a, b, c) ≡ orient2d(b, c, a)  (cyclic permutation)
- **`proof fn lemma_orient2d_translation`** — [orient2d.rs:659](./src/orient2d.rs#L659)
  > orient2d(a, b, c) is translation-invariant: orient2d(add_vec2(a,t), add_vec2(b,t), add_vec2(c,t)) ≡ orient2d(a, b, c)

## `orient3d`

### Spec Functions

- **`open spec fn orient3d`** — [orient3d.rs:16](./src/orient3d.rs#L16)
  > 3D orientation predicate: orient3d(a, b, c, d) = triple(b-a, c-a, d-a)

### Proof Functions

- **`proof fn lemma_orient3d_swap_cd`** — [orient3d.rs:70](./src/orient3d.rs#L70)
  > orient3d(a, b, d, c) ≡ -orient3d(a, b, c, d)  (swap last two)
- **`proof fn lemma_orient3d_swap_bc`** — [orient3d.rs:83](./src/orient3d.rs#L83)
  > orient3d(a, c, b, d) ≡ -orient3d(a, b, c, d)  (swap middle two)
- **`proof fn lemma_orient3d_cycle_bcd`** — [orient3d.rs:97](./src/orient3d.rs#L97)
  > orient3d(a, c, d, b) ≡ orient3d(a, b, c, d)  (cyclic permutation of b,c,d)
- **`proof fn lemma_orient3d_degenerate_ab`** — [orient3d.rs:115](./src/orient3d.rs#L115)
  > orient3d(a, a, c, d) ≡ 0  (degenerate: a = b)
- **`proof fn lemma_orient3d_degenerate_cd`** — [orient3d.rs:140](./src/orient3d.rs#L140)
  > orient3d(a, b, c, c) ≡ 0  (degenerate: c = d)
- **`proof fn lemma_orient3d_translation`** — [orient3d.rs:152](./src/orient3d.rs#L152)
  > orient3d is translation-invariant

## `point2`

### Spec Functions

- **`open spec fn sub2`** — [point2.rs:47](./src/point2.rs#L47)
  > Point subtraction: point - point = vector
- **`open spec fn add_vec2`** — [point2.rs:52](./src/point2.rs#L52)
  > Point-vector addition: point + vector = point

### Proof Functions

- **`proof fn lemma_sub2_self_zero`** — [point2.rs:61](./src/point2.rs#L61)
  > sub2(a, a) ≡ Vec2::zero()
- **`proof fn lemma_sub2_translation`** — [point2.rs:70](./src/point2.rs#L70)
  > sub2(add_vec2(b, t), add_vec2(a, t)) ≡ sub2(b, a)

## `point3`

### Spec Functions

- **`open spec fn sub3`** — [point3.rs:51](./src/point3.rs#L51)
  > Point subtraction: point - point = vector
- **`open spec fn add_vec3`** — [point3.rs:56](./src/point3.rs#L56)
  > Point-vector addition: point + vector = point

### Proof Functions

- **`proof fn lemma_sub3_self_zero`** — [point3.rs:65](./src/point3.rs#L65)
  > sub3(a, a) ≡ Vec3::zero()
- **`proof fn lemma_sub3_translation`** — [point3.rs:75](./src/point3.rs#L75)
  > sub3(add_vec3(b, t), add_vec3(a, t)) ≡ sub3(b, a)

